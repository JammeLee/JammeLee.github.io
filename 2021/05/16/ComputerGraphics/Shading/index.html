
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shading - Jamme</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Jamme,"> 
    <meta name="description" content="Illumination &amp;amp; ShadingShading: Definition
In Merriam-Webster Dictionary
​    shad·ing, [ˈʃeɪdɪŋ,"> 
    <meta name="author" content="Jamme"> 
    <link rel="alternative" href="atom.xml" title="Jamme" type="application/atom+xml"> 
    <link rel="icon" href="/img/my_favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Jamme</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://blog.jammelee.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Shading</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Shading</h1>
        <div class="stuff">
            <span>五月 16, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Games101/" rel="tag">Games101</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="Illumination-amp-Shading"><a href="#Illumination-amp-Shading" class="headerlink" title="Illumination &amp; Shading"></a>Illumination &amp; Shading</h3><h4 id="Shading-Definition"><a href="#Shading-Definition" class="headerlink" title="Shading: Definition"></a>Shading: Definition</h4><ul>
<li><p>In Merriam-Webster Dictionary</p>
<p>​    shad·ing, [ˈʃeɪdɪŋ], noun </p>
<p>​    The darkening or coloring of an illustration or diagram with parallel lines or a block of color.</p>
</li>
<li><p>In this course</p>
<p>​    The process of applying a material to an object.</p>
</li>
</ul>
<h4 id="A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model"><a href="#A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model" class="headerlink" title="A Simple Shading Model (Blinn-Phong Reflectance Model)"></a>A Simple Shading Model (Blinn-Phong Reflectance Model)</h4><ul>
<li>Specular highlights（镜面高光）</li>
<li>Diffuse reflection（漫反射）</li>
<li>Ambient lighting（环境光）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608205432.png" alt="img"></p>
<!--![img](\Shading Note\20200608205432.png)-->
<h5 id="Shading-is-Local"><a href="#Shading-is-Local" class="headerlink" title="Shading is Local"></a>Shading is Local</h5><p>Compute light reflected toward camera at a specific shading point.</p>
<p>Inputs: </p>
<ul>
<li>Viewer direction, $ v $</li>
<li>Surface normal, $ n $</li>
<li>Light direction, $ l $ (for each of many lights) </li>
<li>Surface parameters(color, shininess, …)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608205843.png" alt=""></p>
<!--![img](Shading Note\20200608205843.png)-->
<p>No shadows will be generated! (shading ≠ shadow) </p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608210044.png" alt=""></p>
<!-- ![img](Shading Note\20200608210044.png) -->
<h5 id="Diffuse-Reflection"><a href="#Diffuse-Reflection" class="headerlink" title="Diffuse Reflection"></a>Diffuse Reflection</h5><ul>
<li>But how much light (energy) is received?<ul>
<li>Lambert’s cosine law</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608210753.png" alt="img"></p>
<ol>
<li>立方体的顶面接收一定量的光</li>
<li>旋转60度的立方体顶面只截取了一半的光</li>
<li>通常，每个单位面积的光与<script type="math/tex">\cos(\theta) = l · n</script>成正比</li>
</ol>
<h5 id="Light-Falloff"><a href="#Light-Falloff" class="headerlink" title="Light Falloff"></a>Light Falloff</h5><p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608212142.png" alt="img"></p>
<p>半径为1的球面上，光的强度为I。球的面积公式为<script type="math/tex">4\pi R^{2}</script>， 所以图中最远处的球面上，光强度为<script type="math/tex">I/R^{2}</script>。</p>
<h5 id="Lambertian-Diffuse-Shading"><a href="#Lambertian-Diffuse-Shading" class="headerlink" title="Lambertian (Diffuse) Shading"></a>Lambertian (Diffuse) Shading</h5><p>Shading independent of view direction</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608212954.png" alt="img"></p>
<ul>
<li>$k_{d}$： 漫反射项的系数 （vector类型，分别代表RGB，0-1）<ul>
<li>如果等于1，就代表该点完全不吸收能量，进来多少反射多少</li>
<li>如果等于0，就代表该点吸收了所有能量，没有能量反射出去</li>
</ul>
</li>
<li>$I/r^{2}$：到达shading point的能量</li>
<li>$max(0, n · l)$：有多少能量会被接收，因为n和l为单位向量，所以余弦值就是两个向量点乘，如果余弦值为负数，则无物理意义。</li>
</ul>
<p>漫反射打到一个点上，反射光应该是各个方向均匀分布，所以从哪个角度观察，结果都是一模一样的，所以公式和向量v没有任何关系。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608225954.png" alt="img"></p>
<h5 id="Specular-Term-Blinn-Phong"><a href="#Specular-Term-Blinn-Phong" class="headerlink" title="Specular Term (Blinn-Phong)"></a>Specular Term (Blinn-Phong)</h5><p>镜面反射项，Blinn-Phong模型（高光）</p>
<p>镜面反射强度取决于观察方向</p>
<ul>
<li>接近镜面反射方向</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608220955.png" alt="img"></p>
<p>$v$距离镜面反射方向越近，半程向量越接近法向量</p>
<ul>
<li>用单位向量的点积测量接近程度</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608221458.png" alt="img"></p>
<ul>
<li>$ k_{s} $：镜面反射系数，通常认为是一个白色</li>
<li>$(I/r^{2})$：到达shading point的能量</li>
<li>$max(0, n·h)^{p}$：使用点乘计算半程向量和法向量的夹角余弦值，从而判断两个向量的接近程度<ul>
<li>n：法向量</li>
<li>h：半程向量，使用平行四边形法则，向量v加上向量l求出半程向量，除以向量的模得出半程向量的单位向量h</li>
<li>p：指数，因为余弦值用来判断两个向量的接近程度，容忍度太高，会导致高光面积过大，所以需要加一个指数。正常再Blinn-Phong模型中大概会用到100-200。（如下图)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608223149.png" alt="img"></p>
<p>这里因为Blinn-Phong模型是一个经验模型，所以不考虑shading poing有多少能量被吸收。</p>
<p>使用镜面反射向量r和观察向量v做点乘也可以判断这两个向量的远近程度，从而判断高光。此模型被称为Phong模型，Blinn-Phong模型是Phong模型的一个改进，因为半程向量的计算量低于反射向量的计算量。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608223317.png" alt="img"></p>
<h5 id="Ambient-Term"><a href="#Ambient-Term" class="headerlink" title="Ambient Term"></a>Ambient Term</h5><p>环境光</p>
<p>做一个大胆的假设，任何一个点接收到来自环境的光永远都是相同的，强度叫做$ I_{a} $。任何点都有自己的一个颜色，$k_{a}$环境光的系数。把$k_{a}$和$I_{a}$结合在一起，我们就可以近似的得出一个环境光。可以保证没有地方是完全黑色的。</p>
<h5 id="Blinn-Phong-Reflection-Model"><a href="#Blinn-Phong-Reflection-Model" class="headerlink" title="Blinn-Phong Reflection Model"></a>Blinn-Phong Reflection Model</h5><p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200608225152.png" alt="img"></p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
L &= L_{a} + L_{d} + L_{s} \\
&= k_{a}I_{a} + k_{d}(I/r^{2})max(0, n·l) + k_{s}(I/r^{2})max(0, n·h)^{p}\\
\end{split}
\end{equation}</script><h4 id="Shading-Frequencies"><a href="#Shading-Frequencies" class="headerlink" title="Shading Frequencies"></a>Shading Frequencies</h4><h5 id="Shading-Frequency-Face-Vertex-or-Pixel"><a href="#Shading-Frequency-Face-Vertex-or-Pixel" class="headerlink" title="Shading Frequency: Face, Vertex or Pixel"></a>Shading Frequency: Face, Vertex or Pixel</h5><p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609111554.png" alt="img"></p>
<p>着色频率取决于几何面或者顶点出现的频率，当面出现的频率已经很高的情况下，就不需要使用复杂的逐像素着色。</p>
<h5 id="Defining-Per-Vertex-Normal-Vectors"><a href="#Defining-Per-Vertex-Normal-Vectors" class="headerlink" title="Defining Per-Vertex Normal Vectors"></a>Defining Per-Vertex Normal Vectors</h5><p>最好的方法是从基础的集合获取顶点的法线。例如下图（上），当我们知道我们所要渲染的几何是个球体，那么顶点表示的就是球面上的点，可以通过求该顶点所在球面的法线来获取顶点法线。但是现实情况中，并不能够总是渲染一个已知的规则几何。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609112815.png" alt="img"></p>
<p>所以我们需要通过三角面的法线来推断顶点法线，其中最简单的方案就是，求顶点所关联的所有面法线之和的平均，然后再做归一化操作，得出该顶点的法线。</p>
<script type="math/tex; mode=display">
N_{v} = \frac{\sum_i N_{i}}{||\sum_i N_{i}||}</script><h5 id="Defining-Per-Pixel-Normal-Vectors"><a href="#Defining-Per-Pixel-Normal-Vectors" class="headerlink" title="Defining Per-Pixel Normal Vectors"></a>Defining Per-Pixel Normal Vectors</h5><p>Barycentric interpolation (introducing soon) of vertex normals</p>
<p>顶点法线的重心插值</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609114951.png" alt="img"></p>
<h4 id="Graphics-Real-time-Rendering-Pipeline"><a href="#Graphics-Real-time-Rendering-Pipeline" class="headerlink" title="Graphics (Real-time Rendering) Pipeline"></a>Graphics (Real-time Rendering) Pipeline</h4><p>图形管线（实时渲染管线）流程</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609184456.png" alt="img"></p>
<p>顶点处理，做一些顶点变换</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609184555.png" alt="img"></p>
<p>顶点处理和三角形处理后，进行光栅化三角形</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609184952.png" alt="img"></p>
<p>片段（像素）处理，深度测试（有些教材把深度测试归为光栅化阶段）</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609185037.png" alt="img"></p>
<p>着色阶段有两个</p>
<ul>
<li>顶点着色，高洛德着色（Gouraud Shading）</li>
<li>片段着色，Phong着色（Phong Shading）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609185228.png" alt="img"></p>
<p>纹理映射</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609185602.png" alt="img"></p>
<h5 id="Shader-Programs"><a href="#Shader-Programs" class="headerlink" title="Shader Programs"></a>Shader Programs</h5><ul>
<li>Vertex shader</li>
<li>Fragment shader</li>
</ul>
<p>这里拿一个GLSL的片段着色程序来做实例：</p>
<ul>
<li>着色方法在每个片段上执行一次</li>
<li>在当前片段的屏幕采样点输出表面颜色</li>
<li>该着色器执行纹理查找以获取表面的材质颜色，然后执行漫射照明计算</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> myTexture; <span class="comment">// program parameter</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightDir; <span class="comment">// program parameter</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> uv; <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> norm; <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line"><span class="type">void</span> diffuseShader()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">vec3</span> kd;</span><br><span class="line"> kd = texture2d(myTexture, uv); <span class="comment">// material color from texture</span></span><br><span class="line"> kd *= <span class="built_in">clamp</span>(<span class="built_in">dot</span>(–lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// Lambertian shading model</span></span><br><span class="line"> <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(kd, <span class="number">1.0</span>); <span class="comment">// output fragment color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Goal-Highly-Complex-3D-Scenes-in-Realtime"><a href="#Goal-Highly-Complex-3D-Scenes-in-Realtime" class="headerlink" title="Goal: Highly Complex 3D Scenes in Realtime"></a>Goal: Highly Complex 3D Scenes in Realtime</h5><ul>
<li>100’s of thousands to millions of triangles in a scene </li>
<li>Complex vertex and fragment shader computations</li>
<li>High resolution (2-4 megapixel + supersampling) </li>
<li>30-60 frames per second (even higher for VR)</li>
</ul>
<h4 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h4><h5 id="Surfaces-are-2D"><a href="#Surfaces-are-2D" class="headerlink" title="Surfaces are 2D"></a>Surfaces are 2D</h5><p>任何一个三维物体它的表面都是二维的。</p>
<p>任意3D表面上的点都对应2D图片上的一个位置，这个2D图片就称为纹理（Texture）。把这个图片通过拉伸、压缩等方式蒙在3D物体的表面，这个过程就叫做纹理映射（Texture Mapping）。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609193337.png" alt="img"></p>
<p>每个三角形将一块纹理图片“拷贝”到表面。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609194915.png" alt="img"></p>
<p>每一个三角形的顶点上都分配有一个纹理坐标（Texture Coordinate，（u,v））</p>
<ul>
<li>$ u $：代表横向坐标，越红代表值越大</li>
<li>$ v $：代表纵向坐标，越绿代表值越大</li>
<li>坐标值在区间$ [0,1] $上，方便计算任何分辨率大小的纹理的坐标</li>
</ul>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609195433.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609195505.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609195633.png" alt="img"></p>
<p>可视化的纹理坐标</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609195729.png" alt="img"></p>
<p>纹理是可以复用的，即同一个纹理可以被多次使用。这种纹理在图形学中被统称为无缝纹理贴图（Tileable Texture）。这种纹理的设计需要各种各样的算法，其中一种算法叫做Wang  Tiled。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200609195905.png" alt="img"></p>
<h5 id="Interpolation-Across-Triangles-Barycentric-Coordinates"><a href="#Interpolation-Across-Triangles-Barycentric-Coordinates" class="headerlink" title="Interpolation Across Triangles:Barycentric Coordinates"></a>Interpolation Across Triangles:Barycentric Coordinates</h5><p>三角形的插值：重心坐标</p>
<p>我们为什么要引入插值？</p>
<ul>
<li>三角形顶点的值都是额定的</li>
<li>平滑过渡</li>
</ul>
<p>我们使用插值都做了些什么？</p>
<ul>
<li>纹理坐标插值</li>
<li>颜色插值</li>
<li>法线插值</li>
</ul>
<p>重心坐标是定义在三角形上的，在三角形ABC构成的平面内，任何一点(x, y)都可以表示成A、B、C这三个顶点坐标的线性组合。</p>
<script type="math/tex; mode=display">
(x,y)=\alpha A+\beta B+\gamma C \\
\alpha+\beta+\gamma=1</script><p>当系数$\alpha$、$\beta$、$\gamma$都非负时，该点在三角形内；否则在三角形外。如果三个系数之和不为1，那么该点不在三角形构成的平面内。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611194235.png" alt="img"></p>
<p>那么三角形A点的重心坐标是多少呢，显而易见：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
(\alpha, \beta, \gamma) &= (1, 0, 0) \\
(x, y) &= \alpha A+\beta B+\gamma C \\
&= A
\end{split}
\end{equation}</script><p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611194644.png" alt="img"></p>
<p>在几何定义下，我们可以通过面积之比来计算三个系数$ \alpha $、$ \beta $、$ \gamma $。</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
\alpha &= \frac{A_{A}}{A_{A}+A_{B}+A_{C}} \\
\beta &= \frac{A_{B}}{A_{A}+A_{B}+A_{C}} \\
\gamma &= \frac{A_{C}}{A_{A}+A_{B}+A_{C}} \\
\end{split}
\end{equation}</script><p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611195210.png" alt="img"></p>
<p>在重心坐标系下，三角形的重心是多少呢？</p>
<p>根据重心的性质，重心和三角形的三个顶点连接起来，会将三角形等分为三份，即三个等面积的三角形。那么根据上边的公式可以得出：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
(\alpha, \beta, \gamma) &= (\frac{1}{3}, \frac{1}{3}, \frac{1}{3}) \\
(x, y) &= \frac{1}{3} A+\frac{1}{3} B+\frac{1}{3} C \\
\end{split}
\end{equation}</script><p>同时，三角形的面积可以通过向量的叉乘计算：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
\alpha &= \frac{-(x-x_{B})(y_{C}-y_{B})+(y-y_{B})(x_{C}-x_{B})}{-(x_{A}-x_{B})(y_{C}-y_{B})+(y_{A}-y_{B})(x_{C}-x_{B})} \\
\beta &= \frac{-(x-x_{C})(y_{A}-y_{C})+(y-y_{C})(x_{A}-x_{C})}{-(x_{B}-x_{C})(y_{A}-y_{C})+(y_{B}-y_{C})(x_{A}-x_{C})} \\
\gamma &= 1-\alpha-\beta \\
\end{split}
\end{equation}</script><p>我们需要插值的属性，也同样可以通过重心坐标线性的组合出来。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611201227.png" alt="img"></p>
<p>但是，重心坐标在投影变化下，并不是不变的。所以光栅化中的深度测试，需要先做逆变换，然后对三维空间中的坐标做插值。</p>
<h5 id="Applying-Textures"><a href="#Applying-Textures" class="headerlink" title="Applying Textures"></a>Applying Textures</h5><p>如何进行纹理映射？</p>
<p>先对三角形中的采样点进行纹理坐标插值，得到$(u,v)$坐标，然后在纹理上查询$(u,v)$值，得出这个点上的颜色。我们可以认为这个颜色就是漫反射系数$k_{d}$，然后经过Phong Shading的计算，将这个颜色值设置到物体上，即相当于将图贴到了物体上，且带有漫反射、高光、环境光等效果。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611203539.png" alt="img"></p>
<h5 id="Texture-Magnification"><a href="#Texture-Magnification" class="headerlink" title="Texture Magnification"></a>Texture Magnification</h5><h6 id="纹理的放大，即纹理的分辨率不足"><a href="#纹理的放大，即纹理的分辨率不足" class="headerlink" title="纹理的放大，即纹理的分辨率不足"></a>纹理的放大，即纹理的分辨率不足</h6><p>A pixel on a texture — a texel (纹理元素、纹素)</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611205422.png" alt="img"></p>
<ul>
<li>Bilinear Interpolation（双线性插值）</li>
</ul>
<p>如下图，我们想要在红点处采样纹理值，其中黑点代表纹理采样点。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611205548.png" alt="img"></p>
<p>取四个临近的采样点</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611210145.png" alt="img"></p>
<p>令两个采样点之间的距离为1，以四个点的左下角为0点，然后可以通过水平距离$s$和垂直距离$t$，找到红点的位置。</p>
<p>通过线性插值（Linear interpolation (1D)）操作，即</p>
<script type="math/tex; mode=display">
lerp(x,v_{0},v_{1})=v_{0}+x(v_{1}-v_{0})</script><p>当x=0时，插值等于$v_{0}$；当x=1时，插值等于$v_{1}$。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611210957.png" alt="img"></p>
<p>那么，我们对下边这条边，即左下角和右下角这两个点，使用$s$做插值；同理，上边这条边，我们也可以使用$s$对左上角和右上角两点进行插值。即，</p>
<script type="math/tex; mode=display">
u_{0}=lerp(s,u_{00},y_{10}) \\
u_{1}=lerp(s,u_{01},y_{11})</script><p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611211030.png" alt="img"></p>
<p>最后，我们再使用$t$做一次竖直方向上的插值。即，</p>
<script type="math/tex; mode=display">
f(x,y)=lerp(t,u_{0},u_{1})</script><p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611211743.png" alt="img"></p>
<p>双线性插值通常以合理的成本给出相当不错的结果。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200611211859.png" alt="img"></p>
<p>但是，双线性插值（Bilinear Interpolation）也存在一些问题，对于一些更高级的方法，双线性插值的质量还是差一些。</p>
<h6 id="纹理过大，也就是纹理的分辨率过于大"><a href="#纹理过大，也就是纹理的分辨率过于大" class="headerlink" title="纹理过大，也就是纹理的分辨率过于大"></a>纹理过大，也就是纹理的分辨率过于大</h6><p>纹理过大，采样后会出现什么问题呢？</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200612212033.png" alt="img"></p>
<p>没错，近处会出现锯齿，远处会出现摩尔纹。</p>
<p>为什么会出现这种走样的情况？</p>
<p>因为近处一个像素所覆盖的纹理上的区域相对较小，但是在远处一个像素就覆盖了一片纹理区域。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200612213031.png" alt="img"></p>
<p>那么我们依旧可以采用超采样的方法，得出一个不错的结果，但是使用超采样会有一个问题，那就是开销问题。增加采样点，必然会使整个算法变得特别慢。当然，我们也不希望一个算法会变得超级慢。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200612213558.png" alt="img"></p>
<p>如果不使用超采样方法的话，我们仅需要得到该像素所对应的范围内的平均值即可。范围查询不只是我们用的这一种应用——平均查询，还有很多类型的范围查询，比如说查询范围内的最大值、最小值等。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200612221107.png" alt="img"></p>
<p>不同像素在纹理上的覆盖对应不同大小。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200612221257.png" alt="img"></p>
<h5 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h5><p>允许（快速，近似，正方形）范围查询</p>
<p>“ Mip”来自拉丁语“multum in parvo”，意思是有很多不同的小的东西。</p>
<p>其实Mipmap就是从一张图生成一系列图，假如说第一张图叫做Level 0，那么我们可以生成更多更高层的纹理，使得每一层$i$，都是第$i-1$层的长和宽缩小一半，直到最后剩下一个点。一共$log_{2}n$层，$n$为分辨率。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613161356.png" alt="img"></p>
<p>对应到Mipmap中，我们生成的是如下图这样的东西，第0层为原始的图像，上边总比下边小一半。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613161446.png" alt="img"></p>
<p>所以在计算机视觉界，大家不把它称作Mipmap，而是称作Image pyramid（图像金字塔）。</p>
<p>Mipmap所造成的额外存储仅是原来的$\frac{1}{3}$，使用级数求和可以计算得出。</p>
<script type="math/tex; mode=display">
\sum_{n=1}^{\infty}{1+\frac{1}{4^n}}</script><p>还有一种理解方式，可以把每一层的存储都乘以3（不影响最终结果），并把第0层的三份分别放在左下角、左上角、右上角，然后把第一层的三份分别放在空置的右下角方块中，并且依旧按照左下角、左上角、右上角，那么右下角再次空出，以此类推把剩余层填入剩余的空间。则会发现，最外层除了三份0层，剩下的层都放在了右下角，所以得出$\frac{1}{3}$。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613165212.png" alt="img"></p>
<h6 id="计算Mipmap层"><a href="#计算Mipmap层" class="headerlink" title="计算Mipmap层"></a>计算Mipmap层</h6><p>任何像素都会有一个对应的映射在纹理上的区域</p>
<p>如下图，要计算左下方的红点所占据的像素的覆盖面积，我们可以取这个像素的中心点和它相邻像素的中心点，分别投影到纹理上去。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613165710.png" alt="img"></p>
<p>求出纹理上，该点相对于上方相邻点和右方相邻点的长度，就可以近似计算出这个像素在纹理上所占区域的边长。这个边长就作为以该像素中心点为重心，所占正方形区域的边长。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613170321.png" alt="img"></p>
<p>接下来，我们应该如何根据预计算好的Mipmap，去查询这个边长为$L$的正方形区域内的平均值？</p>
<p>我们可以假设，如果这个正方形的区域大小是1x1，就是一个像素，那我们可以在没有做过Mipmap的最原始的纹理上找对应的像素。</p>
<p>如果这个正方形的大小是4x4，那我们可以得出这个区域一定会在第2层上变成1个像素。为什么呢？我们可以思考一下，这个区域的大小是4x4，是指在最原始的图片上的大小是4x4。那么经过第一层Mipmap后，这个区域会变成2x2，然后经过第二层Mipmap之后，这个区域会变成1x1。</p>
<p>这个$L*L$大小的区域，一定会在$log_{2}L$层上对应到1个像素。也就是说我们只要计算出这个区域在第几层变成了一个像素，那么我们就可以去查找那个像素，即立刻得出这个区域的平均值是多少。</p>
<p>如果说对于每个像素，我们都计算它投影到纹理上对应的区域，然后根据这个区域的大小，计算出应该在第几层Mipmap上去找这个像素的平均值，那我们就可以做一个可视化。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613172503.png" alt="img"></p>
<p>虽然在上图中，我们发现这些颜色有些渐变，但是会发现一个问题，那就是这些颜色的变化并不连续。因为我们只查询了第0层、第1层、第2层等等的整数层，如果我们想要查询第1.5层、第1.8层，应该怎么办呢？</p>
<p>那当然是使用插值</p>
<p>假设我们想查询第1.8层，那么应该先查询第一层，再查询第二层。在这两层内部，分别使用双线性插值，把所在的这两层上的查询先做出来；然后把这两层插值得出的值，再做一次插值，即相当于在层与层之间做了一次插值。一共做了三次插值，我们把它称作<strong>三线性插值（Trilinear Interpolation）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613174601.png" alt="img"></p>
<p>再来对比一下原图、超采样、Mipmap。</p>
<p>原图：</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613174846.png" alt="img"></p>
<p>使用512x超采样：</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613174856.png" alt="img"></p>
<p>Mipmap：</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613174913.png" alt="img"></p>
<p>我们会发现Mipmap似乎并不太对，远处全部模糊了起来。</p>
<p>原因在于，Mipmap只能查询到正方形区域内的插值。我们可以使用<strong>各向异性过滤（Anisotropic Filtering ）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613180516.png" alt="img"></p>
<p>Mipmap所做的事情就是在原图上一直把长宽缩小一般，那么对应到下图中其实Mipmap就是做了对角线上的计算。但是有一些图需要作不同长宽比的预计算，这个就是Mipmap中所没有的。</p>
<p><strong>各向异性过滤</strong></p>
<p>各向异性是指，在不同的方向上表现各不相同。我们原本认为在正方形的水平和垂直方向上，表现完全相同，就叫做各向同性。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613180827.png" alt="img"></p>
<p>我们可以看到上图中，每一行都做了水平方向上的压缩，每一列都是垂直方向上的压缩。它相比于Mipmap多了一些水平方向和垂直方向上不均匀的压缩。</p>
<p>通过这样的一种方式的预计算，就可以查询到任何一个被压扁了的图的位置，即可以查询原图的一个矩形区域，而不用被限制在一个正方形的区域内。</p>
<p>因为屏幕上的任何一个像素映射在纹理上，不一定都是一个规律的形状，很可能出现斜着的、极细的形状，如下图。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613182020.png" alt="img"></p>
<p>例如上（右）图中，左上方斜长条区域，如果我们把它近似成一个正方形区域，就相当于求了一个更大区域的平均，所以会造成<strong>Overblur（过于模糊）</strong>。</p>
<p>如果我们引入各向异性过滤，例如上（右）图中，右上方的长条区域就可以得到一个近乎完美的解决，因为各向异性过滤允许我们对这种长条形的区域做一个快速的查询。</p>
<p>我们可以通过上边带有卫星的那张图片分析出，各向异性过滤所生成的图，总共的开销是原本的3倍（原图占左上角的1/4）。各向异性过滤生成的图有一个名字，叫做<strong>Ripmap</strong>。而Mipmap所需的开销比原本多1/3，这里可以供我们参考一下。</p>
<p>如果大家经常打游戏的话，会接触到一个各向异性过滤相关的概念，就是多少x，这里的x其实指的就是计算多少层，比如说2x指的就是方向上压缩了一次，就是上边带有卫星的那张图片中的左上角四个卫星的区域，以此类推，4x就是在2x的基础上又压缩了一次，就是上边带有卫星的那张图片中的左上角九个卫星的区域，即左上角$((log_{2}{n})+1)^2$个卫星，n代表nx。</p>
<p>我们会发现，n的增加，最后的结果会逐渐收敛至原图的三倍，也就是说各向异性过滤的存储量和用户开nx的关系不大。应用各向异性过滤，只要显存足够，其实和计算力基本没有关系，所以在游戏中将各向异性过滤开至最高也几乎不会对游戏有性能的影响。</p>
<p>但是各向异性过滤仍然不能解决斜着的区域，要解决这个问题，可以使用一些另外的方法，比如EWA filtering。</p>
<p><strong>EWA filtering</strong></p>
<ul>
<li>Use multiple lookups</li>
<li>Weighted average</li>
<li>Mipmap hierarchy still helps</li>
<li>Can handle irregular footprints</li>
</ul>
<p>任意一个不规则的形状都可以被拆分成很多圆形，以覆盖这个不规则形状。例如，有一个椭圆形（如下图），可以把它拆分成三个不同的圆形，然后每次去查询一个圆形，然后多次查询，自然就可以去覆盖一个不规则的形状。但是代价就是牺牲时间，因为查询时需要耗时的。</p>
<p><img src="https://raw.githubusercontent.com/JammeLee/MyPicBed/master/BlogPic/20200613183416.png" alt="img"></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://music.163.com/song/media/outer/url?id=33255251.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://music.163.com/song/media/outer/url?id=27571001.mp3'></li>
                        
                    
                        
                            <li title='2' data-url='http://music.163.com/song/media/outer/url?id=33211947.mp3'></li>
                        
                    
                        
                            <li title='3' data-url='http://music.163.com/song/media/outer/url?id=22705492.mp3'></li>
                        
                    
                        
                            <li title='4' data-url='http://music.163.com/song/media/outer/url?id=27602839.mp3'></li>
                        
                    
                        
                            <li title='5' data-url='http://music.163.com/song/media/outer/url?id=857606.mp3'></li>
                        
                    
                        
                            <li title='6' data-url='http://music.163.com/song/media/outer/url?id=33911781.mp3'></li>
                        
                    
                        
                            <li title='7' data-url='http://music.163.com/song/media/outer/url?id=32465542.mp3'></li>
                        
                    
                        
                            <li title='8' data-url='http://music.163.com/song/media/outer/url?id=29829683.mp3'></li>
                        
                    
                        
                            <li title='9' data-url='http://music.163.com/song/media/outer/url?id=1322517422.mp3'></li>
                        
                    
                        
                            <li title='10' data-url='http://music.163.com/song/media/outer/url?id=424262056.mp3'></li>
                        
                    
                        
                            <li title='11' data-url='http://music.163.com/song/media/outer/url?id=428350227.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci='37860e80e52e63fd571f'
        data-cs='8715681fdb97a249e736cc9495e0f7a6efccbe1c'
        data-r='JammeLee.github.io'
        data-o='JammeLee'
        data-a='JammeLee'
        data-d='true'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Illumination-amp-Shading"><span class="toc-number">1.</span> <span class="toc-text">Illumination &amp; Shading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Shading-Definition"><span class="toc-number">1.1.</span> <span class="toc-text">Shading: Definition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model"><span class="toc-number">1.2.</span> <span class="toc-text">A Simple Shading Model (Blinn-Phong Reflectance Model)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Shading-is-Local"><span class="toc-number">1.2.1.</span> <span class="toc-text">Shading is Local</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Diffuse-Reflection"><span class="toc-number">1.2.2.</span> <span class="toc-text">Diffuse Reflection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Light-Falloff"><span class="toc-number">1.2.3.</span> <span class="toc-text">Light Falloff</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lambertian-Diffuse-Shading"><span class="toc-number">1.2.4.</span> <span class="toc-text">Lambertian (Diffuse) Shading</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Specular-Term-Blinn-Phong"><span class="toc-number">1.2.5.</span> <span class="toc-text">Specular Term (Blinn-Phong)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Ambient-Term"><span class="toc-number">1.2.6.</span> <span class="toc-text">Ambient Term</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Blinn-Phong-Reflection-Model"><span class="toc-number">1.2.7.</span> <span class="toc-text">Blinn-Phong Reflection Model</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shading-Frequencies"><span class="toc-number">1.3.</span> <span class="toc-text">Shading Frequencies</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Shading-Frequency-Face-Vertex-or-Pixel"><span class="toc-number">1.3.1.</span> <span class="toc-text">Shading Frequency: Face, Vertex or Pixel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Defining-Per-Vertex-Normal-Vectors"><span class="toc-number">1.3.2.</span> <span class="toc-text">Defining Per-Vertex Normal Vectors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Defining-Per-Pixel-Normal-Vectors"><span class="toc-number">1.3.3.</span> <span class="toc-text">Defining Per-Pixel Normal Vectors</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Graphics-Real-time-Rendering-Pipeline"><span class="toc-number">1.4.</span> <span class="toc-text">Graphics (Real-time Rendering) Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Shader-Programs"><span class="toc-number">1.4.1.</span> <span class="toc-text">Shader Programs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Goal-Highly-Complex-3D-Scenes-in-Realtime"><span class="toc-number">1.4.2.</span> <span class="toc-text">Goal: Highly Complex 3D Scenes in Realtime</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Texture-Mapping"><span class="toc-number">1.5.</span> <span class="toc-text">Texture Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Surfaces-are-2D"><span class="toc-number">1.5.1.</span> <span class="toc-text">Surfaces are 2D</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Interpolation-Across-Triangles-Barycentric-Coordinates"><span class="toc-number">1.5.2.</span> <span class="toc-text">Interpolation Across Triangles:Barycentric Coordinates</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Applying-Textures"><span class="toc-number">1.5.3.</span> <span class="toc-text">Applying Textures</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Texture-Magnification"><span class="toc-number">1.5.4.</span> <span class="toc-text">Texture Magnification</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E7%9A%84%E6%94%BE%E5%A4%A7%EF%BC%8C%E5%8D%B3%E7%BA%B9%E7%90%86%E7%9A%84%E5%88%86%E8%BE%A8%E7%8E%87%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">纹理的放大，即纹理的分辨率不足</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E8%BF%87%E5%A4%A7%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E7%BA%B9%E7%90%86%E7%9A%84%E5%88%86%E8%BE%A8%E7%8E%87%E8%BF%87%E4%BA%8E%E5%A4%A7"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">纹理过大，也就是纹理的分辨率过于大</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mipmap"><span class="toc-number">1.5.5.</span> <span class="toc-text">Mipmap</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97Mipmap%E5%B1%82"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">计算Mipmap层</span></a></li></ol></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
